# TEST PLAN

# Methodology

_How are you creating test cases?_

First, we consider common classes of implementation error:

1. Signed/unsigned:

Is sign extension happening to all the right immediates (most of them) and none
of the wrong ones? Instructions to test: all except R-format, which has no immediates.
Immediates not to sign-extend: those in I-format shifting instructions.

Does the implementation always use signed operations for signed operands and
unsigned for unsigned? e.g. does ADD v1, v2 get coded using a signed add
function? Instructions to test: all ALU instructions regardless of format (R-format
instructions are for implicitly signed operations) except shifting, all branch, jump,
load, and store instructions (the immediate as offset is added to the base address;
memory addresses are unsigned values so this should be an unsigned operation). 

2. For instructions where order matters, the implementation may reverse the intended order
of operands. Instructions to test: SUB, SL T, SL TI, SL TIU, BL T, BL TU, BGE, BGEU.

3. Treatment of immediates. Instructions to test: all except R-format. Specific treatment for each type of immediate (and per specific instructions, where relevant) is found in the outline of test cases.

4. Alignment: For taken branches and unconditional jumps, an exception occurs on the branch or
jump instruction if the address is not aligned on a 4-byte boundary in memory. Instructions to test: JAL, JALR, BEQ, BNE, BL T, BL TU, BGE, BGEU. Note that our implementation allows unaligned memory accesses for load and store instructions, so we do not test for it.

5. Overflow checking is left to the programmer. RISC-V doesn’t throw an exception, it just truncates and returns the low 32 bits, so we test that this is happening.

6. Endianness: we should test some multi-byte loads and stores to make sure we’re handling them correctly. The system is likely to be little-endian, so are we treating the word at the lowest memory address as the least significant byte and loading it into the least significant register byte, and vice versa for stores? Then, for each specific instruction, we also do a case analysis of its possible outcomes, given the intended correct behavior of the instruction. For example, an AND instruction could be reduced to its operation on all four possible permutations of 2 bits: it should result in a 1 if both bits are set, and a 0 otherwise.

_How does one execute and run the test cases?_

There are tests in the source files that can be run using the `cargo test` command. These are also
run automatically because `cargo test` is run as part of CI.

There are also some tests in `programs/` that use the exit code checking method: `ld_str.mem`’s
expected return value is 42, and `simple_test_mem.mem` returns the difference between an expected and actual value as the exit code (so 0 indicates correctness). For these tests, there is a makefile (also in `programs/`) to compile/assemble them. The exit code of the emulator will be whatever was in `$a0`, so you can test based off of that. The `--dump-to FILE` option dumps program state at the end of execution and allows you to compare register values to expected values.
There is also the option of using the `--suppress-status` flag, in which case 0 indicates success
and 1 indicates that one or more exceptions occurred.

In addition to all this, there is a testing framework (on the feature branch `testFramework`), the
tests for which can be run as follows:

From top-level directory,
`sudo apt install cmake` if you don’t already have it
`cd testing`
`cmake -S . -B build`
`cmake --build build`
`cd load`
`./loadTest` will execute the entire test suite
`./test_executable --gtest_filter=TestSuiteName.TestName` runs a single test

Changes can be made to the assembly and expected results file without having to re-compile
the test.

_How are you verifying?_

The test framework keeps the simulator output of all failed tests, so we can examine program
state when the failure occurred. The expected results are generated by hand. 

# Outline of Test Cases

Note, the “things to check” part refers to anything beyond checking the actual values generated
by case analysis against their expected values.

# ALU R-Format Instructions

## ADD
Semantics: rd ← rs1 + rs2. Signed addition.
Case analysis:
- rs1 > 0 and rs2 > 0 ⇒ rd > rs1, rs2.
- rs1 < 0 and rs2 < 0 ⇒ rd < rs1, rs2
- rs1 > 0 and rs2 < 0 ⇒ rd < rs1
- rs1 = 0 and rs2 = 0 ⇒ rd = 0
- rs1 = 0 and rs2 != 0 ⇒ rd = rs2
Things to check:
- was addition implemented as signed addition
- Did overflow mechanism behave correctly (returning the low 32 bits)

## SUB
Semantics: rd ← rs1 - rs2. Signed subtraction.
Case analysis:
- rs1 > rs2 ⇒ rd > 0
- rs1 = rs2 ⇒ rd = 0
- rs1 < rs2 ⇒ rd < 0
Things to check:
- was subtraction implemented as signed subtraction

## AND
Semantics: rd ← rs1 & rs2. Bitwise and.
Case analysis:
- rs1[0] = 1 and rs2[0] = 1 ⇒ rd[0] = 1
- otherwise rd[0] = 0

## OR
Semantics: rd ← rs1 | rs2. Bitwise or.
Case analysis:
- rs1[0] = 0 and rs2[0] = 0 ⇒ rd[0] = 0
- otherwise rd[0] = 1

## XOR
Semantics: rd ← rs1 ^ rs2. Bitwise exclusive or.
Case analysis:
- rs1[0] != rs2[0] ⇒ rd[0] = 1
- otherwise rd[0] = 0

## SLL
Semantics: rd ← rs1 <<logical rs2.
Things to check:
- value in rs2 should be positive
- zero fill on the right

## SRL
Semantics: rd ← rs1 >>logical rs2.
Things to check:
- value in rs2 should be positive
- zero fill on the left

## SRA
Semantics: rd ← rs1 >>arithmetic rs2.
Things to check:
- value in rs2 should be positive
- fill with sign bit on the left

## SLT
Semantics: rd ← 1 if rs1 < rs2 else 0. Signed comparison.
Case analysis:
- rs1 < rs2 ⇒ rd = 1
- otherwise rd = 0
Things to check:
- was comparison implemented as signed

## SLTU
Semantics: same as above, except unsigned comparison.
Case analysis/things to check for: same as above, except this time it is correct to have
implemented an unsigned comparison.

# ALU I-Format Instructions

## ADDI
Semantics: rd ← rs1 + sign-extend(imm12).
Case analysis:
- rs1 > 0 and imm12 > 0 ⇒ rd > rs1, imm12
- rs1 < 0 and imm12 < 0 ⇒ rd < rs1, imm12
- rs1 > 0 and imm12 < 0 ⇒ rd < rs1
- rs1 = 0 and imm12 = 0 ⇒ rd = 0
- rs1 = 0 and imm12 != 0 ⇒ rd = imm12
Things to check:
- was imm12 sign-extended
- was addition implemented as signed

## ANDI
Semantics: rd ← rs1 & sign-extend(imm12).
Case analysis:
- rs1[0] = 1 and imm12[0] = 1 ⇒ rd[0] = 1
- otherwise rd[0] = 0

## ORI
Semantics: rd ← rs1 | sign-extend(imm12).
Case analysis:
- rs1[0] = 0 and imm12[0] = 0 ⇒ rd[0] = 0
- otherwise rd[0] = 1

## XORI
Semantics: rd ← rs1 ^ sign-extend(imm12).
Case analysis:
- rs1[0] != imm12[0] ⇒ rd[0] = 1
- otherwise rd[0] = 0

## SLLI
Semantics: rd ← rs1 << logical imm12[4:0].
Things to check:
- value in imm12[4:0] should be positive
- zero fill on the right
- the implementation should not have sign-extended the immediate, as it is not being used
as a value but contains further encoding

## SRLI
Semantics: rd ← rs1 >>logical imm12[4:0].
Things to check:
- value in imm12[4:0] should be positive
- zero fill on the left
- the implementation should not have sign-extended the immediate, as it is not being used
as a value but contains further encoding

## SRAI
Semantics: rd ← rs1 >>arithmetic imm12[4:0].
Things to check:
- value in imm12[4:0] should be positive
- the implementation should not have sign-extended the immediate, as it is not being used
as a value but contains further encoding
- fill with sign bit on the left

## SLTI
Semantics: rd ← 1 if rs1 < imm12 else 0. Signed comparison.
Case analysis:
- rs1 < imm12 ⇒ rd = 1
- otherwise rd = 0
Things to check:
- was comparison implemented as signed

## SLTIU
Semantics: same as above, except unsigned comparison. Note that first the immediate is
sign-extended, and the result is then treated as an unsigned value.
Case analysis/things to check for: same as above, except this time it is correct to have
implemented an unsigned comparison. And make sure the immediate was sign-extended
despite this being an operation on unsigned values.

# U-Format Instructions

## LUI
Semantics: rd ← (imm20 << 12).
Things to check: 
- did the immediate get shifted by the proper amount
- `R[rd] = {imm,12'b0}`
- sign extending
- make sure the sign extended value ends up in the destination register
- make sure there are 12'b0x0 in the LSBs and the value we want is in the MSB

## AUIPC
Semantics: rd ← (imm20 << 12) + address(AUIPC)
Things to check:
- `R[rd] = PC + {imm, 12'b0}`
- program counter should be in an expected state, run PC, probably just start at 
  0x0
- Also set some nops so PC is at a different value for another test
- set sign extended concatenated value {imm,12'b0} to some known reg to check it 
  at the end of the program

# Loads and Stores

## LW
Semantics: 
- val ← mem[rs1 + sign-extend(imm12)]32.
- sign-extend(val)
- rd ← val
Things to check:
- was immediate sign-extended
- was val sign-extended
- is memory address aligned correctly

## LH
Semantics: 
- val ← mem[rs1 + sign-extend(imm12)]16.
- sign-extend(val)32
- rd ← val
Things to check:
- was immediate sign-extended
- was val sign-extended to 32 bits
- is memory address aligned correctly

## LB
Semantics: 
- val ← mem[rs1 + sign-extend(imm12)]8.
- sign-extend(val)32
- rd ← val
Things to check: same as LH above

## LHU
Semantics: same as LH, except zero-extend the value to 32 bits before loading it (note that the
immediate used as memory offset is still sign-extended!).
Things to check:
- were exactly 16 bits retrieved from memory
- was immediate sign-extended (even though the result value will be unsigned!)
- was value from memory zero-extended to 32 bits
- is memory address aligned correctly

## LBU
Semantics: same as LHU, except value loaded is 8 bits instead of 16.
Things to check: same as LHU, except 8 bits retrieved from memory.

## SW
Semantics: mem[rs1 + sign-extend(imm12)] ← rs2.
Things to check:
- was immediate sign-extended
- Is memory address aligned correctly

## SH
Semantics: mem[rs1 + sign-extend(imm12)] ← rs2[15:0].
Things to check:
- was immediate sign-extended
- Is memory address aligned correctly
- are we storing the low 16 bytes of rs2

## SB
Semantics: mem[rs1 + sign-extend(imm12)] ← rs2[15:0].
Things to check:
- was immediate sign-extended
- Is memory address aligned correctly
- are we storing the low 8 bytes of rs2

# Branch Instructions

## BEQ
Semantics: 
- tgt ← (sign-extend(imm12) << 1)32 + address(BEQ)
- if rs1 == rs2 then PC ← tgt 
- else PC ← PC + 4
Case analysis for comparison:
- rs1 == rs2 (branch should be taken)
- otherwise branch should not be taken
Things to check:
- was immediate sign-extended and shifted right by 1
- did correct address get used as base

## BNE
Semantics: 
- tgt ← (sign-extend(imm12) << 1)32 + address(BNE)
- if rs1 != rs2 then PC ← tgt else PC ← PC + 4
Case analysis for comparison:
- rs1 != rs2 (branch should be taken)
- otherwise branch should not be taken
Things to check: same as BEQ

## BLT
Semantics: 
- tgt ← (sign-extend(imm12) << 1)32 + address(BL T)
- if rs1 < signed rs2 then PC ← tgt else PC ← PC + 4
Case analysis for comparison, taking into account the common implementation error of confusing
signed and unsigned:
- rs1 < rs2 where MSB(rs1) == MSB(rs2). Should branch.
- rs1 < rs2 where MSB(rs1) == 1 and MSB(rs2) == 0. Should branch, but will not branch if
comparison is mistakenly implemented as unsigned, because rs1 will be interpreted as
large positive number, causing the expression to evaluate to false.
- rs1 > rs2 where MSB(rs1) == MSB(rs2). Should not branch.
- rs1 > rs2 where MSB(rs1) == 1 and MSB(rs2) == 0. Should not branch, but will if
comparison is mistakenly implemented as unsigned, because rs1 will be interpreted as
large positive number, causing the comparison to evaluate to true.
- rs1 == rs2. Should not branch.

## BLTU
Semantics: 
- tgt ← (sign-extend(imm12) << 1)32 + address(BL TU)
- if rs1 < unsigned rs2 then PC ← tgt else PC ← PC + 4
Case analysis for comparison, taking into account the common implementation error of confusing
signed and unsigned:
- rs1 < rs2 where MSB(rs1) == MSB(rs2). Should branch.
- rs1 < rs2 where MSB(rs1) == 0 and MSB(rs2) == 1. Should branch, but will not branch if
comparison is mistakenly implemented as signed, because rs2 will be interpreted as
negative number, causing the expression to evaluate to false.
- rs1 > rs2 where MSB(rs1) == MSB(rs2). Should not branch.
- rs1 > rs2 where MSB(rs1) == 0 and MSB(rs2) == 1. Should not branch, but will if
comparison is mistakenly implemented as signed, because rs2 will be interpreted as
negative number, causing the comparison to evaluate to true.
- rs1 == rs2. Should not branch.

## BGE
Semantics: 
- tgt ← (sign-extend(imm12) << 1)32 + address(BGE)
- if rs1 >= signed rs2 then PC ← tgt else PC ← PC + 4
Case analysis for comparison, taking into account the common implementation error of confusing
signed and unsigned:
- rs1 >= rs2 where MSB(rs1) == MSB(rs2). Should branch.
- rs1 >= rs2 where MSB(rs1) == 0 and MSB(rs2) == 1. Should branch, but will not branch if
comparison is mistakenly implemented as unsigned, because rs2 will be interpreted as
large positive number, causing the expression to evaluate to false.
- rs1 < rs2 where MSB(rs1) == MSB(rs2). Should not branch.
- rs1 < rs2 where MSB(rs1) == 1 and MSB(rs2) == 0. Should not branch, but will if
comparison is mistakenly implemented as unsigned, because rs1 will be interpreted as
large positive number, causing the comparison to evaluate to false.

## BLTU
Semantics: 
- tgt ← (sign-extend(imm12) << 1)32 + address(BLTU)
- if rs1 >= unsigned rs2 then PC ← tgt else PC ← PC + 4
Case analysis for comparison, taking into account the common implementation error of confusing
signed and unsigned:
- rs1 >= rs2 where MSB(rs1) == MSB(rs2). Should branch.
- rs1 >= rs2 where MSB(rs1) == 1 and MSB(rs2) == 0. Should branch, but will not branch if
comparison is mistakenly implemented as signed, because rs1 will be interpreted as
negative number, causing the expression to evaluate to false.
- rs1 < rs2 where MSB(rs1) == MSB(rs2). Should not branch.
- rs1 < rs2 where MSB(rs1) == 0 and MSB(rs2) == 1. Should not branch, but will if
comparison is mistakenly implemented as signed, because rs2 will be interpreted as
negative number, causing the comparison to evaluate to false.

# Jump Instructions

## JAL
Semantics: 
- tgt ← (sign-extend(imm20) << 1)32 + address(JAL)
- rd ← PC + 4
Things to check:
- did immediate get sign-extended and shifted left by one?
- is target address aligned?

## JALR
Semantics: 
- tgt ← ((sign-extend(imm12) << 1)32 & 0 ) + address(JALR)
- rd ← PC + 4
Things to check: same as above, plus did the 32-bit value resulting from sign-extending the
12-bit immediate and shifting it left by 1 also get its LSB zeroed out?
